


<style>
  body {
    font-size: 5.5pt;
    /* font-size: 12pt; */
    color: magenta;
    /* color: rgb(255, 100, 255); */
    /* background-color: rgb(255, 200, 255); */
    /* background: magenta; */
    /* color: pink; */
    /* text-align: justify; */
    /* text-align: right; */
    /* direction: rtl; */
  }
  ::selection {
    /* color: snow; */
    background: rgb(255, 211, 255);
  }
  @media print {
    body {
      /* color: black; */
    }
  }
  code {
    font-size: 9pt;
    color: magenta;
    /* unicode-bidi: bidi-override; */
  }
  method, mthd {
    display: block;
    /* border: 1px solid magenta; */
    /* border-left: 1px dotted cyan; */
    /* padding: 0; */
    /* float: left; */
    white-space: pre;
    /* font-family: pixel, moonspace, monospace; */
    margin: .5em .5em .5em 1.8em;
    margin: .5em;
    margin: 0 1em 1em;
    /* padding-left: .2em; */

    /* float: right; */
    /* margin: .5em 1.8em .5em .5em; */
    /* unicode-bidi: bidi-override; */
  }
  class, function, block {
    display: block;
    /* white-space: pre; */
  }
  class ol {
    padding-left: 2em;
  }
  block,
  case {
    white-space: pre;
    font-family: monospace;
  }
  case {
    display: block;
    float: left;
    /* max-height: 20em; */
    /* overflow: hidden; */
  }
  captian > case,
  ol.switch captian > li.case {
    float: none;
  }
  ol.switch {
    clear: both;
  }
  ol.switch li.case {
    float: left;
  }
  pre {
    display: block;
    float: left;

    /* float: right;
    unicode-bidi: bidi-override; */
  }
  clear {
    clear: both;
  }
  captian {
    /* width: 1.3in; */
    display: block;
    float: left;

    /* float: right; */
  }
  group {
    display: block;
    clear: both;
  }
  comment {
    color: lightpink;
    /* color: snow; */
  }
  @media print {
    page-break {
      display: block;
      page-break-after: always;
    }
  }
  </style>


<script src="bubblescript.js">
</script>
<script type="text/bubblescript">
</script>

<function style="float: left; margin: .5em 5em .5em 1.4em; clear: both;">
<pre style="margin-bottom: 0;">function bubbleParse(s, stack = []) {</pre>
<group>
<captian><pre>  var word = null,
    list = null,
    glider = null,
    string = /^\".*\"$/,
    number = /^\d+$/,
</pre></captian><captian><pre>
    keyword = /^:.+$/,
    stropen = false, // string open flag
    checkcomment = false,
    comment = false,
    count = 0,
</pre></captian><captian><pre>
    counts = [],
    depth = 0, // number of open enclosures
    lc = null,
    progress = 0;

</pre></captian>
<group>
<captian><pre>
  each(s.split(''), function(c) {
<div style="clear: both;"><captian><pre>
    if (stropen) {
      word += c;
      if (c == '"') {
        stropen = false;
        // word = new String(word);
        word = word.slice(1, word.length - 1);
        stack.push(word);
        count++;
        word = null;
      }
      return;
    }
</pre></captian><captian><pre>
    if (comment) {
      if (c == "\n")
        comment = false;
      return;
    }
</pre></captian>

<pre style="clear: both;">
    switch (c) {</pre>
<group style="font-size: 3pt; height: 2.8in; position: absolute; top: 2.6in; margin-left: .15in;"><captian><pre>
      case '(':
        stack.push(LParen);
        depth++;
        counts.push(count);
        count = 0;
        break;
      case '[':
        stack.push(LBrack);
        depth++;
        counts.push(count);
        count = 0;
        break;
      case "'":
        stack.push(SingleQ);
        count++;
        break;
      case '"':
        stropen = true;
        word = c;
        // count++;
        // stack.push(DoubleQ);
        break;
</pre></captian><captian><pre>
      case ')':
        if (typeof word == "string") {
          switch (true) {
            case number.test(word):
              word = parseInt(word);
              break;
            case /^(\d+)?\.\d+$/.test(word):
              word = parseFloat(word);
              break;
            case keyword.test(word):
              word = new Keyword(word.substr(1));
              break;
            case /^\"(.*)\"$/.test(word):
              // strip quotes
              word = /^\"(.*)\"$/.exec(word)[1];
              break;
            case /^.+$/.test(word):
              word = new Symbol(word);
          }
        }

        if (word == null) word = stack.pop();
        if (word == LParen) {
          // stack.push(new List)
          stack.push(emptyList);
          word = null;
          break;
        }

        while (arry.peek(stack) == SingleQ) {
          stack.pop()
          count--;
          word = new Quoted(word);
        }

        list = new List(word);

        word = stack.pop();
        count--;
        while (word !== LParen) {
          list = list.push(word);
          // skip spaces
          // if(arry.peek(stack) == Space)
          //   stack.pop()
          word = stack.pop();
          count--;
        }

        while (arry.peek(stack) == SingleQ) {
          stack.pop();
          count--;
          list = new Quoted(list);
        }
</pre></captian><captian><pre>
        depth--;
        count = counts.pop();
        word = null;
        stack.push(list);
        count++;
        list = null;
        break;

      case ']':
        if (typeof word == "string") {
          // if (word) {
          switch (true) {
            case number.test(word):
              word = parseInt(word);
              break;
            case /^(\d+)?\.\d+$/.test(word):
              word = parseFloat(word);
              break;
            case keyword.test(word):
              word = new Keyword(word.substr(1));
              break;
            case /^\"(.*)\"$/.test(word): //string
              word = /^\"(.*)\"$/.exec(word)[1];
              break;
            case /^.+$/.test(word):
              word = new Symbol(word);
          }
        }

        if (word == null) {
          word = stack.pop();
          count--;
        }
        if (word == LBrack) {
          // stack.push(new Glider);
          stack.push(emptyGlider);
          depth--;
          word = null;
          break;
        }

        while (arry.peek(stack) == SingleQ) {
          stack.pop()
          count--;
          word = new Quoted.new(word)
        }

        tmp = [];
        while (word !== LBrack) {
          tmp.push(word);
          // skip spaces
          // if(arry.peek(stack) == Space)
          //   stack.pop()
</pre></captian><captian><syntax-case>
          word = stack.pop();
          count--;
        }
        word = null;

        glider = new Glider(tmp.pop());
        while (tmp.length > 0) {
          glider = glider.push(tmp.pop());
        }

        while (arry.peek(stack) == SingleQ) {
          stack.pop();
          count--;
          glider = new Quoted(glider);
        }

        depth--;
        count = counts.pop();
        stack.push(glider);
        count++;
        glider = null;
        break;

      case ' ':
      case "\n":
      case ',':
        // if (word) { // clear word
        if (typeof word == "string") {
          switch (true) {
            case number.test(word):
              word = parseInt(word);
              break;
            case /^(\d+)?\.\d+$/.test(word):
              word = parseFloat(word);
              break;
            case keyword.test(word):
              word = new Keyword(word.substr(1));
              break;
            case /^\"(.*)\"$/.test(word):
              // strip quotes
              word = /^\"(.*)\"$/.exec(word)[1];
              break;
            case word == 'true':
              word = true;
              break;
            case word == 'false':
              word = false;
              break;
            case /^.+$/.test(word):
              word = new Symbol(word);
          }

</syntax-case></captian><captian><pre>
          if (depth > 0)

            while (arry.peek(stack) == SingleQ) {
              stack.pop()
              count--;
              word = new Quoted(word)
            }

          if (word) {
            stack.push(word);
            count++;
            word = null;
          }
          // stack.push(Space);
        }
        if (c == "\n" && lc != ',') {
          // if (depth == 0 && count > 1) {
          if (depth == 0) {
            let d = stack.length - progress;
            if (d > 1) {
              // implied list
              word = stack.pop();
              d--;
              count--;

              // while (arry.peek(stack) == SingleQ) {
              //  stack.pop()
              //  word = new Quoted(word);
              //  count--;
              // }

              list = new List(word);

              // while(count > 0) {
              //   word = stack.pop();
              //   count--;
              //   list = list.push(word);
              // }
              for (; d > 0; d--) {
                word = stack.pop()
                //   // list.push(stack.pop());
                if (word == SingleQ) {
                  let q = new Quoted(list.peek());
                  list = list.pop();
                  list = list.push(q);
                } else {
                  list = list.push(word);
                }
                //
              }

              word = null;
              stack.push(list);
              list = null;
            }
            progress = stack.length; // cinch
          }
          // count = 0;
          // xstack.push(stack.pop())
          // while (stack.length!=0){
          // stack2.push(stack.shift())
          // }
        }

        // if (c==',')
        // comma = true;

        break;
        //case ".":
        if (word) {
          switch (true) {
            case /^\d+\.$/.test(word):
            case /^:.+$/.test(word):
              word += c;
              return;
            case /^.+$/.test(word):
              stack.push(new Symbol(word));
              word = null;
              stack.push(Dot);
              count += 2;
              return;
          }
        } else {
          word = c;
        }
        break;
        //case '/':
        if (word) {
          if (arry.peek(stack) != Slash) {
            stack.push(new Symbol(word));
            word = null;
            stack.push(Slash);
            count += 2;
          } else {
            word += c;
          }
        } else {
          word = c;
        }
        break;
        // case '\':

</pre></captian><captian><pre>
      case '%':
        comment = true;
        break;
      case '/':
        if (lc == '/') {
          comment = true;
        }
        break;
      default:
        if (word) {
          word += c;
        } else {
          word = c;
          // count += 1;
        }
</pre></captian></group>


<pre style="clear:both; margin-top: 3in;">    } <comment>/* ** END SWITCH ** */</comment></pre>
<group><captian><pre>
    if (c && c != ' ' && c != ';')
      lc = c;
</pre></captian></group>
<pre style="clear:both;">  }); <comment>/* ** END EACH ** */</comment></pre>
</div>
</pre></captian></group>
<group><captian><block>  if (word) {
    switch (true) {
      case number.test(word):
        word = parseInt(word);
        break;
      case keyword.test(word):
        word = new Keyword(word.substr(1));
        break;
      case /^.+$/.test(word):
        word = new Symbol(word);
        break;
    }

    while (arry.peek(stack) == SingleQ) {
      stack.pop();
      count--;
      word = new Quoted(word);
    }

    stack.push(word);
    count++;
    word = null;
  }
</block></captian>
<captian><block> if (depth == 0) {
    let d = stack.length - progress;
    if (d > 1) {
      word = stack.pop();
      d--;
      count--;

      list = new List(word);

      for (; d > 0; d--) {
        word = stack.pop()
        if (word == SingleQ) {
          let q = new Quoted(list.peek());
          list = list.pop();
          list = list.push(q);
        } else {
          list = list.push(word);
        }
      }

      word = null;
      stack.push(list);
      list = null;
    }
    progress = stack.length; // cinch
  }</block>
</captian></group>
<br style="clear: both;">
<pre>

  // return stack2;
  // for(var w of stack) {
  //   console.log(w.toString());
  // }
  return stack;

} <comment>// END bubbleParse \\ {</comment></pre>
</function>
