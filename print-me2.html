


<style>
  body {
    font-size: 5.5pt;
    /* font-size: 12pt; */
    color: magenta;
    color: rgb(255, 100, 255);
    background-color: rgb(255, 200, 255);
    /* background: magenta; */
    /* color: pink; */
    /* text-align: justify; */
    /* text-align: right; */
    /* direction: rtl; */
  }
  @media print {
    body {
      /* color: black; */
    }
  }
  code {
    font-size: 9pt;
    color: magenta;
    /* unicode-bidi: bidi-override; */
  }
  method, mthd {
    display: block;
    /* border: 1px solid magenta; */
    /* border-left: 1px dotted cyan; */
    /* padding: 0; */
    /* float: left; */
    white-space: pre;
    /* font-family: pixel, moonspace, monospace; */
    margin: .5em .5em .5em 1.8em;
    margin: .5em;
    margin: 0 1em 1em;
    /* padding-left: .2em; */

    /* float: right; */
    /* margin: .5em 1.8em .5em .5em; */
    /* unicode-bidi: bidi-override; */
  }
  class, function, block {
    display: block;
    /* white-space: pre; */
  }
  class ol {
    padding-left: 2em;
  }
  block,
  case {
    white-space: pre;
    font-family: monospace;
  }

  case {
    display: block;
    float: left;
    /* max-height: 20em; */
    /* overflow: hidden; */
  }
  captian > case,
  ol.switch captian > li.case {
    float: none;
  }
  ol.switch {
    clear: both;
  }
  ol.switch li.case {
    float: left;
  }
  pre {
    display: block;
    float: left;

    /* float: right;
    unicode-bidi: bidi-override; */
  }
  clear {
    clear: both;
  }
  captian {
    /* width: 1.3in; */
    display: block;
    float: left;

    /* float: right; */
  }
  group {
    display: block;
    clear: both;
  }
  @media print {
    page-break {
      display: block;
      page-break-after: always;
    }
  }
  </style>


<script src="bubblescript.js">
</script>
<script type="text/bubblescript">
  </script>


<div>
<pre>
            /**   BUbBLeScript
                         Version 0.1.4.üë∏üë±‚Äç‚ôÄÔ∏è   **/



(function() {                   //                    } ()noitcnuf)

  class BUbBLeScript {          //           } tpircSeLBbUB ssalc
      parse {}                  //                {} esrap
  }                             //                            {

  var emptyList,
    emptyGlider;
  </pre>
</div>
<!-- <page-break></page-break> -->

<div style=" float: left; clear:left; margin: .5em 5em .5em 1.4em;">
<pre style="margin-bottom: 1.5em;">class                    {</pre>
<captian  style="clear:both;">

<method>conj(val) {
  return val.reduce(function(memo, i) {
    return memo.push(i);
  }, this);
}</method>

<method>constructor(head, tail) {
  this.head = head;
  this.tail = tail;
}</method>

<method>count {
  return this.reduce(function(memo, i) {
    return memo + 1;
  }, 0);
}</method>

<method>each(fn) {
  var result = fn(this.head);
  if (this.tail)
    return this.tail.each(fn);
  return result;
}</method>



<method>get first {
  return this.head;
}</method>


<method>get rest {
  return this.tail;
}</method>

<method>get next {
  return this.tail.head;
}</method>


<method>get isEmpty { return false; }</method>

<method>get last {
  return this.tail ? this.tail.last : this.head;
}</method>

<method>inspect {
  "(" + map(function(q) {
    q.inspect()
  }).join() + ")"
}</method>


</captian>
<captian>

<method>join(delimiter = ' ') {
  if (this.tail) {
    return this.head + delimiter + this.tail.join()
  } else {
    if (typeof this.head == "string") {
      return '"' + this.head + '"';
    }
    return this.head.toString()
  }
}</method>
<method>map(fn) {
  var tail = null,
    head;
  if (this.tail)
    tail = this.tail.map(fn);
  head = fn(this.head);
  return new List(head, tail);
}</method>

<method>peek {
  return this.head;
}</method>

<method>pop {
  return this.tail || emptyList;
}</method>

<method>push(val) {
  return new List(val, this);
}</method>

<method>shift {
  return this.reverse().pop().reverse();
}</method>


</captian>

<captian>

<method>reduce(fn, memo) {
  var a, b, c = this;
  if (memo == undefined) {
    a = this.head;
    c = this.tail;
    if (!c) {
      return a;
    } else {
      b = c.head;
      c = c.tail;
      memo = fn(a, b);
      if (!c)
        return memo;
    }
  }
  return c.push(memo).reduce(fn);
}</method>

<method>reverse {
  if (!this.tail) return this;
  var list = new List(this.head);
  return this.tail.reduce(function(memo, i) {
    return memo.push(i);
  }, list);
}</method>

<method>toArray {
  if (this.tail) {
    return [this.head].concat(this.tail.toArray());
  } else {
    return [this.head];
  }
}</method>

<method>toString {
  return "(" + this.join() + ")"
}</method>



</captian>

<pre style="clear:both;">}</pre>
</div>

<!-- <page-break></page-break> -->

<class style="float: left; margin: .5em 5em .5em 1.4em;">
<pre style="margin-bottom: 1.5em;">class                     {</pre>
<ol>
<captian  style="clear:both;">

<method><li>(head, tail) {
  this.head = head;
  this.tail = tail;
}</li></method>

<method><li>conj(...val) {
  return val.reduce(function(i, memo) {
    memo.push(i);
  }, this);
}</li></method>

<method><li>each(fn) {
  if (this.tail)
    this.tail.each(fn);
  fn(this.head);
}</li></method>

<method><li>get isEmpty { return false; }</li></method>

<method><li>get first {
   return @tail ?
     @tail.first : @head
}</li></method>

<method><li>get second {
  return @rest.first;
}</li></method>

<method>//get first {
//  if @tail,
//    @tail.first  @head
//}</method>

<method><li>get rest {
  if (@_rest == null)
    if (@tail)
      @_rest =
        new Glider(@head,
          @tail.rest);

  return @_rest;
}</li></method>

<method><li>inspect {
  "[" + this.map(function(q) {
    q.inspect()
  }).join() + "]";
}</li></method>

</captian>
<captian>
<method><li>join(delimiter = ' ') {
  if (this.rest)
    return this.first + delimiter + this.rest.join();
  else
  if (typeof this.first == "string")
    return '"' + this.first + '"';
  else
    return this.first + '';
}</li></method>

<method><li>map(fn, ...aux) {
  var tail = null;

  var result = new Glider(fn(this.first,
    ...aux.map(function(q) {
      return q ? q.first : q
    })));

  if (!this.rest)
    return result;

  function into(a, b) {
    var c = new Glider(b.peek());
    b = b.pop();

    while (!b.isEmpty) {
      c = c.push(b.peek());
      b = b.pop();
    }
    while (!c.isEmpty) {
      a = a.push(c.peek());
      c = c.pop();
    }

    return a;
  }

  return into(result, this.rest.map(fn,
    ...aux.map(function(q) {
      return q.rest
    })));
}</li></method>
</captian>

<captian>

<method><li>mapp(fn, ...aux) {
  var tail = null;

  var result = new Glider(fn(this.first,
    ...aux.map(function(q) {
      return q ? q.first : q
    })));

  return this.rest.map(function(...args) {
    return new Glider(fn(...args), result);
  }, ...aux.map(function(q) {
    return q.rest
  }));

}</li></method>

<method><li>peek {
  return this.head;
}</li></method>
<method><li>pop {
  return this.tail || emptyGlider;
}</li></method>
<method><li>push(val) {
  return new Glider(val, this);
}</li></method>

<method><li>reduce(fn, memo) {
  if (this.tail)
    memo = this.tail.reduce(fn, memo);
  return fn(this.head, memo);
}</li></method>

<method><li>toString {
  return "[" + this.join() + "]"
}</li></method>

</captian>

</ol>
<pre style="clear:both;">}</pre>
</class>
<!-- <page-break></page-break> -->
<class style="float: left; margin: .5em 5em .5em 1.4em;">
<pre style="margin-bottom: 1.5em;">class EmptyList extends List {</pre>
<ol>
<captian  style="clear:both;">
<method><li>get [is empty] { return true; }</li></method>
<method><li>map { return this; }</li></method>
<method><li>push(val) {
  return new List(val);
}</li></method>
<method><li>reverse {
  return this;
}</li></method>
<method><li>[to string] {
  return "()";
}</li></method>
</captian>
</ol>

<pre style="clear:both;">}</pre>
</class>


<class style="float: left; margin: .5em 5em .5em 1.4em;">
<pre style="margin-bottom: 1.5em;">class EmptyGlider extends Glider {</pre>
<ol>
<captian  style="clear:both;">
<method><li>get [is empty] { return true }</li></method>

<method><li>push (val) {
  return new Glider(val);
}</li></method>

<method><li>[to string] {
  return "[]";
}</li></method>
</captian>
</ol>

<pre style="clear:both;">}</pre>
</class>
<pre>  emptyGlider =  new EmptyGlider;
  emptyList   =  new EmptyList;
</pre>


<page-break></page-break>

<function style="float: left; margin: .5em 5em .5em 1.4em; clear: both;">
<pre style="margin-bottom: 0;">function bubbleParse(s, stack = []) {</pre>
<group>
<captian><pre>  var word = null,
    list = null,
    glider = null,
    string = /^\".*\"$/,
    number = /^\d+$/,
</pre></captian><captian><pre>
    keyword = /^:.+$/,
    stropen = false, // string open flag
    checkcomment = false,
    comment = false,
    count = 0,
</pre></captian><captian><pre>
    counts = [],
    depth = 0, // number of open enclosures
    lc = null,
    progress = 0;

</pre></captian>
<group>
<captian><pre>
  each(s.split(''), function(c) {
<div style="clear: both;"><captian><pre>
    if (stropen) {
      word += c;
      if (c == '"') {
        stropen = false;
        // word = new String(word);
        word = word.slice(1, word.length - 1);
        stack.push(word);
        count++;
        word = null;
      }
      return;
    }
    if (comment) {
      if (c == "\n")
        comment = false;
      return;
    }

    switch (c) {
</pre></captian>


<group><captian><pre>
      case '(':
        stack.push(LParen);
        depth++;
        counts.push(count);
        count = 0;
        break;
      case '[':
        stack.push(LBrack);
        depth++;
        counts.push(count);
        count = 0;
        break;
      case "'":
        stack.push(SingleQ);
        count++;
        break;
      case '"':
        stropen = true;
        word = c;
        // count++;
        // stack.push(DoubleQ);
        break;
</pre></captian><captian><pre>
      case ')':
        if (typeof word == "string") {
          switch (true) {
            case number.test(word):
              word = parseInt(word);
              break;
            case /^(\d+)?\.\d+$/.test(word):
              word = parseFloat(word);
              break;
            case keyword.test(word):
              word = new Keyword(word.substr(1));
              break;
            case /^\"(.*)\"$/.test(word):
              // strip quotes
              word = /^\"(.*)\"$/.exec(word)[1];
              break;
            case /^.+$/.test(word):
              word = new Symbol(word);
          }
        }

        if (word == null) word = stack.pop();
        if (word == LParen) {
          // stack.push(new List)
          stack.push(emptyList);
          word = null;
          break;
        }

        while (arry.peek(stack) == SingleQ) {
          stack.pop()
          count--;
          word = new Quoted(word);
        }

        list = new List(word);

        word = stack.pop();
        count--;
        while (word !== LParen) {
          list = list.push(word);
          // skip spaces
          // if(arry.peek(stack) == Space)
          //   stack.pop()
          word = stack.pop();
          count--;
        }

        while (arry.peek(stack) == SingleQ) {
          stack.pop();
          count--;
          list = new Quoted(list);
        }

        depth--;
        count = counts.pop();
        word = null;
        stack.push(list);
        count++;
        list = null;
        break;
</pre></captian><captian><pre>
      case ']':
        if (typeof word == "string") {
          // if (word) {
          switch (true) {
            case number.test(word):
              word = parseInt(word);
              break;
            case /^(\d+)?\.\d+$/.test(word):
              word = parseFloat(word);
              break;
            case keyword.test(word):
              word = new Keyword(word.substr(1));
              break;
            case /^\"(.*)\"$/.test(word): //string
              word = /^\"(.*)\"$/.exec(word)[1];
              break;
            case /^.+$/.test(word):
              word = new Symbol(word);
          }
        }

        if (word == null) {
          word = stack.pop();
          count--;
        }
        if (word == LBrack) {
          // stack.push(new Glider);
          stack.push(emptyGlider);
          depth--;
          word = null;
          break;
        }

        while (arry.peek(stack) == SingleQ) {
          stack.pop()
          count--;
          word = new Quoted.new(word)
        }

        tmp = [];
        while (word !== LBrack) {
          tmp.push(word);
          // skip spaces
          // if(arry.peek(stack) == Space)
          //   stack.pop()
          word = stack.pop();
          count--;
        }
        word = null;

        glider = new Glider(tmp.pop());
        while (tmp.length > 0) {
          glider = glider.push(tmp.pop());
        }

        while (arry.peek(stack) == SingleQ) {
          stack.pop();
          count--;
          glider = new Quoted(glider);
        }

        depth--;
        count = counts.pop();
        stack.push(glider);
        count++;
        glider = null;
        break;
</pre></captian><captian><syntax-case>
      case ' ':
      case "\n":
      case ',':
        // if (word) { // clear word
        if (typeof word == "string") {
          switch (true) {
            case number.test(word):
              word = parseInt(word);
              break;
            case /^(\d+)?\.\d+$/.test(word):
              word = parseFloat(word);
              break;
            case keyword.test(word):
              word = new Keyword(word.substr(1));
              break;
            case /^\"(.*)\"$/.test(word):
              // strip quotes
              word = /^\"(.*)\"$/.exec(word)[1];
              break;
            case word == 'true':
              word = true;
              break;
            case word == 'false':
              word = false;
              break;
            case /^.+$/.test(word):
              word = new Symbol(word);
          }

          if (depth > 0)

            while (arry.peek(stack) == SingleQ) {
              stack.pop()
              count--;
              word = new Quoted(word)
            }

          if (word) {
            stack.push(word);
            count++;
            word = null;
          }
          // stack.push(Space);
        }
        if (c == "\n" && lc != ',') {
          // if (depth == 0 && count > 1) {
          if (depth == 0) {
            let d = stack.length - progress;
            if (d > 1) {
              // implied list
              word = stack.pop();
              d--;
              count--;

              // while (arry.peek(stack) == SingleQ) {
              //  stack.pop()
              //  word = new Quoted(word);
              //  count--;
              // }

              list = new List(word);

              // while(count > 0) {
              //   word = stack.pop();
              //   count--;
              //   list = list.push(word);
              // }
              for (; d > 0; d--) {
                word = stack.pop()
                //   // list.push(stack.pop());
                if (word == SingleQ) {
                  let q = new Quoted(list.peek());
                  list = list.pop();
                  list = list.push(q);
                } else {
                  list = list.push(word);
                }
                //
              }

              word = null;
              stack.push(list);
              list = null;
            }
            progress = stack.length; // cinch
          }
          // count = 0;
          // xstack.push(stack.pop())
          // while (stack.length!=0){
          // stack2.push(stack.shift())
          // }
        }

        // if (c==',')
        // comma = true;

        break;
        //case ".":
        if (word) {
          switch (true) {
            case /^\d+\.$/.test(word):
            case /^:.+$/.test(word):
              word += c;
              return;
            case /^.+$/.test(word):
              stack.push(new Symbol(word));
              word = null;
              stack.push(Dot);
              count += 2;
              return;
          }
        } else {
          word = c;
        }
        break;
        //case '/':
        if (word) {
          if (arry.peek(stack) != Slash) {
            stack.push(new Symbol(word));
            word = null;
            stack.push(Slash);
            count += 2;
          } else {
            word += c;
          }
        } else {
          word = c;
        }
        break;
        // case '\':

</syntax-case></captian><captian><pre>
      case '%':
        comment = true;
        break;
      case '/':
        if (lc == '/') {
          comment = true;
        }
        break;
      default:
        if (word) {
          word += c;
        } else {
          word = c;
          // count += 1;
        }
</pre></captian></group>


<pre style="clear:both;">    } /* ** END CASE ** */</pre>
<group><captian><pre>
    if (c && c != ' ' && c != ';')
      lc = c;
</pre></captian></group>
<pre style="clear:both;">  }); /* ** END EACH ** */</pre>
</div>
</pre></captian></group>
<group><captian><block>  if (word) {
    switch (true) {
      case number.test(word):
        word = parseInt(word);
        break;
      case keyword.test(word):
        word = new Keyword(word.substr(1));
        break;
      case /^.+$/.test(word):
        word = new Symbol(word);
        break;
    }

    while (arry.peek(stack) == SingleQ) {
      stack.pop();
      count--;
      word = new Quoted(word);
    }

    stack.push(word);
    count++;
    word = null;
  }
</block></captian>
<captian><block>  if (depth == 0) {
    let d = stack.length - progress;
    if (d > 1) {
      word = stack.pop();
      d--;
      count--;

      list = new List(word);

      for (; d > 0; d--) {
        word = stack.pop()
        if (word == SingleQ) {
          let q = new Quoted(list.peek());
          list = list.pop();
          list = list.push(q);
        } else {
          list = list.push(word);
        }
      }

      word = null;
      stack.push(list);
      list = null;
    }
    progress = stack.length; // cinch
  }</block>
<pre>

  // return stack2;
  // for(var w of stack) {
  //   console.log(w.toString());
  // }
  return stack;</pre>
</captian></group></group>
<pre style="clear:both;">}</pre>
</function>

<pre style="clear:both;"> })(); </pre>


<page-break></page-break>

    <a id="BREAKIN" href="#BREAKOUT">&Lt;breakout&Gt;</a>
<label  style="display: block;"><a id="BREAKOUT" href="#BREAKIN">&Gt;BREAKIN&Lt;</a></label>




<ol class="switch">
  <captian>
  <li class="case">
      case '(':
        stack.push(LParen);
        depth++;
        counts.push(count);
        count = 0;
        break;
  </li><li class="case">
      case '[':
        stack.push(LBrack);
        depth++;
        counts.push(count);
        count = 0;
        break;
  </li> <li class="case">
      case "'":
        stack.push(SingleQ);
        count++;
        break;
  </li> </captian> <captian> <li class="case">
      case '"':
        stropen = true;
        word = c;
        // count++;
        // stack.push(DoubleQ);
        break;
  </li> <li class="case">
      case ')':

        ...
  </li> <li class="case">
      case ']':
        ...
  </li>
  </captian>
  <li class="case">
      case ' ':
      case "\n":
      case ',':
        ...
  </li> <li class="case">
      case '%':
        comment = true;
        break;
      case '/':
        if (lc == '/') {
          comment = true;
        }
        break;
      default:
        if (word) {
          word += c;
        } else {
          word = c;
          // count += 1;
        }
  </li>
</ol>



<group><captian><pre>
    switch (c) {
      case '(':
        stack.push(LParen);
        depth++;
        counts.push(count);
        count = 0;
        break;
      case '[':
        stack.push(LBrack);
        depth++;
        counts.push(count);
        count = 0;
        break;
      case "'":
        stack.push(SingleQ);
        count++;
        break;
      case '"':
        stropen = true;
        word = c;
        // count++;
        // stack.push(DoubleQ);
        break;
</pre></captian><captian><pre>
      case ')':
        if (typeof word == "string") {
          switch (true) {
            case number.test(word):
              word = parseInt(word);
              break;
            case /^(\d+)?\.\d+$/.test(word):
              word = parseFloat(word);
              break;
            case keyword.test(word):
              word = new Keyword(word.substr(1));
              break;
            case /^\"(.*)\"$/.test(word):
              // strip quotes
              word = /^\"(.*)\"$/.exec(word)[1];
              break;
            case /^.+$/.test(word):
              word = new Symbol(word);
          }
        }

        if (word == null) word = stack.pop();
        if (word == LParen) {
          // stack.push(new List)
          stack.push(emptyList);
          word = null;
          break;
        }

        while (arry.peek(stack) == SingleQ) {
          stack.pop()
          count--;
          word = new Quoted(word);
        }

        list = new List(word);

        word = stack.pop();
        count--;
        while (word !== LParen) {
          list = list.push(word);
          // skip spaces
          // if(arry.peek(stack) == Space)
          //   stack.pop()
          word = stack.pop();
          count--;
        }

        while (arry.peek(stack) == SingleQ) {
          stack.pop();
          count--;
          list = new Quoted(list);
        }

        depth--;
        count = counts.pop();
        word = null;
        stack.push(list);
        count++;
        list = null;
        break;
</pre></captian><captian><pre>
      case ']':
        if (typeof word == "string") {
          // if (word) {
          switch (true) {
            case number.test(word):
              word = parseInt(word);
              break;
            case /^(\d+)?\.\d+$/.test(word):
              word = parseFloat(word);
              break;
            case keyword.test(word):
              word = new Keyword(word.substr(1));
              break;
            case /^\"(.*)\"$/.test(word): //string
              word = /^\"(.*)\"$/.exec(word)[1];
              break;
            case /^.+$/.test(word):
              word = new Symbol(word);
          }
        }

        if (word == null) {
          word = stack.pop();
          count--;
        }
        if (word == LBrack) {
          // stack.push(new Glider);
          stack.push(emptyGlider);
          depth--;
          word = null;
          break;
        }

        while (arry.peek(stack) == SingleQ) {
          stack.pop()
          count--;
          word = new Quoted.new(word)
        }

        tmp = [];
        while (word !== LBrack) {
          tmp.push(word);
          // skip spaces
          // if(arry.peek(stack) == Space)
          //   stack.pop()
          word = stack.pop();
          count--;
        }
        word = null;

        glider = new Glider(tmp.pop());
        while (tmp.length > 0) {
          glider = glider.push(tmp.pop());
        }

        while (arry.peek(stack) == SingleQ) {
          stack.pop();
          count--;
          glider = new Quoted(glider);
        }

        depth--;
        count = counts.pop();
        stack.push(glider);
        count++;
        glider = null;
        break;
</pre></captian><captian><syntax-case>
      case ' ':
      case "\n":
      case ',':
        // if (word) { // clear word
        if (typeof word == "string") {
          switch (true) {
            case number.test(word):
              word = parseInt(word);
              break;
            case /^(\d+)?\.\d+$/.test(word):
              word = parseFloat(word);
              break;
            case keyword.test(word):
              word = new Keyword(word.substr(1));
              break;
            case /^\"(.*)\"$/.test(word):
              // strip quotes
              word = /^\"(.*)\"$/.exec(word)[1];
              break;
            case word == 'true':
              word = true;
              break;
            case word == 'false':
              word = false;
              break;
            case /^.+$/.test(word):
              word = new Symbol(word);
          }

          if (depth > 0)

            while (arry.peek(stack) == SingleQ) {
              stack.pop()
              count--;
              word = new Quoted(word)
            }

          if (word) {
            stack.push(word);
            count++;
            word = null;
          }
          // stack.push(Space);
        }
        if (c == "\n" && lc != ',') {
          // if (depth == 0 && count > 1) {
          if (depth == 0) {
            let d = stack.length - progress;
            if (d > 1) {
              // implied list
              word = stack.pop();
              d--;
              count--;

              // while (arry.peek(stack) == SingleQ) {
              //  stack.pop()
              //  word = new Quoted(word);
              //  count--;
              // }

              list = new List(word);

              // while(count > 0) {
              //   word = stack.pop();
              //   count--;
              //   list = list.push(word);
              // }
              for (; d > 0; d--) {
                word = stack.pop()
                //   // list.push(stack.pop());
                if (word == SingleQ) {
                  let q = new Quoted(list.peek());
                  list = list.pop();
                  list = list.push(q);
                } else {
                  list = list.push(word);
                }
                //
              }

              word = null;
              stack.push(list);
              list = null;
            }
            progress = stack.length; // cinch
          }
          // count = 0;
          // xstack.push(stack.pop())
          // while (stack.length!=0){
          // stack2.push(stack.shift())
          // }
        }

        // if (c==',')
        // comma = true;

        break;
        //case ".":
        if (word) {
          switch (true) {
            case /^\d+\.$/.test(word):
            case /^:.+$/.test(word):
              word += c;
              return;
            case /^.+$/.test(word):
              stack.push(new Symbol(word));
              word = null;
              stack.push(Dot);
              count += 2;
              return;
          }
        } else {
          word = c;
        }
        break;
        //case '/':
        if (word) {
          if (arry.peek(stack) != Slash) {
            stack.push(new Symbol(word));
            word = null;
            stack.push(Slash);
            count += 2;
          } else {
            word += c;
          }
        } else {
          word = c;
        }
        break;
        // case '\':

</syntax-case></captian><captian><pre>
      case '%':
        comment = true;
        break;
      case '/':
        if (lc == '/') {
          comment = true;
        }
        break;
      default:
        if (word) {
          word += c;
        } else {
          word = c;
          // count += 1;
        }
</pre></captian></group>
<pre style="clear:both;">    } /* ** END CASE ** */</pre>
